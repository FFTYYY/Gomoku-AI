'''
用以让分析器调用的术语列表

术语：（来源：百度百科）
〖威胁〗下一手可以成五或者活四的点。

（情况编号）
（每种情况可以对应唯一的一个情况）
0〖连〗2枚以上的同色棋子在一条线上邻接成串
	1〖成五〗五连和长连的统称。
		2〖五连〗五枚同色棋子在一条线上邻接连串。
		3〖长连〗五枚以上同色棋子在一条线上邻接成串。

	4〖四〗五连去掉1子的棋型。
		5〖活四〗有两个威胁的四。
		6〖冲四〗只有一个威胁的四。
		7〖死四〗不能成五的四连。

	8〖三〗可以形成四再形成五的三枚同色棋子组成的棋型。
		9〖活三〗再走一着可以形成活四的三。
		10〖连活三〗两端都是威胁的活三。简称“连三”。
		11〖跳活三〗中间夹有一个威胁的活三。简称“跳三”。
		12〖眠三〗再走一着可以形成冲四的三。
		13〖死三〗不能成五的三。

	14〖二〗可以形成三、四直至五的两枚同色棋子组成的棋型。
		15〖活二〗再走一着可以形成活三的二。
		16〖连活二〗连的活二。简称“连二”。
		17〖跳活二〗中间隔有一个空点的活二。简称“跳二”。
		18〖大跳活二〗中间隔有两个空点的活二。简称“大跳二”。
		19〖眠二〗再走一着可以形成眠三的二。
		20〖死二〗不能成五的二。

'''

'''
	术语和他们对应的正则表达式
	其中_表示空格，o表示己方子，x表示非己方子
'''
terms = {
	"o{6,}" :			"长连",
	"[x_]ooooo[x_]" :	"五连",

	"xoooo_" :			"冲四",
	"xooox" :			"死四",
	"_oooo_" :			"活四",

	"[x_]oo_oo[x_]" :	"冲四",
	"[x_]ooo_o[x_]" :	"冲四",

	"xooox" :			"死三",
	"xooo_x" :			"死三",
	"xoo_ox" :			"死三",

	"xooo__" :			"眠三",
	"x_ooo_x" :			"眠三",

	"x_ooo__" :			"活三",
	"__ooo__" :			"活三",

	"_oo_o_" :			"活三",

	"xoo_o_" :			"眠三",

	"[x_]o_o_o[x_]" :	"眠三",
	"[x_]oo__o[x_]" :	"眠三",

	"x_oo___" :			"活二",
	"__oo__" :			"活二",

	"x_o_o__" :			"活二",
	"__o_o__" :			"活二",

	"_o__o_" :			"活二",

	"xoo___" :			"眠二",
	"xo__o_" :			"眠二",
	"x_o_o_x" :			"眠二",
	"xo_o__" :			"眠二",
	"x_oo__x" :			"眠二",
	"[x_]o___o[x_]" :	"眠二",

	"xoox" :			"死二",
	"xoo_x" :			"死二",
	"xo_ox" :			"死二",
	"xoo__x" :			"死二",
	"xo_o_x" :			"死二",
	"xo__ox" :			"死二",
	"x_oo_x" :			"死二",
}

def deal():
	'''
		处理terms中的对称情况
	'''

	global terms

	terms_2 = {}

	for i in terms:
		j = i[::-1]
		jj = list(j)
		for k in range(len(jj)):
			if(jj[k] == "["):
				jj[k] = "]"
			elif(jj[k] == "]"):
				jj[k] = "["
		for k in range(len(jj)):
			if(k+1 < len(jj) and jj[k] == "x" and jj[k+1] == "]"):
				jj[k] = "_"
			if(k-1 >= 0 	 and jj[k] == "_" and jj[k-1] == "["):
				jj[k] = "x"
		j = "".join(jj)	

		if( (j != i) and (terms[i] != "长连") ):
			terms_2[j] = terms[i]
	terms.update(terms_2)

deal()

NEX = "o" #先手棋子
PAS = "x" #后手棋子
BLA = "_" #空白棋盘

'''
	terms中只包含最底层（叶子）的术语

	这个表示术语树结构
'''
cont_relat = {
	"二" : ["死二","眠二","活二",],
	"三" : ["死三","眠三","活三",],
	"四" : ["死四","冲四","活四",],
	"五" : ["五连","长连",],
}

#cont_relat的逆映射，即查找父亲
better = {}

def deal_better():
	'''
		生成better
	'''
	for _i in cont_relat:
		for _j in cont_relat[_i]:
			better[_j] = _i
deal_better()

if __name__ == "__main__":

	import re

	#for i in terms:
	#	print("{0} : {1}".format(terms[i],i))


	s1 = "xxx____oox___xxx"

	for i in terms:
		p = re.finditer(i,s1)
		if(p):
			for j in p:
				print ("{0} : {1}".format(j.span() , terms[i]))
